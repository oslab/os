21PD03-OPERATING SYSTEMS 
717822P321 1 
 
 
Ex no : 1 
BASIC UNIX COMMANDS Date : 12/02/24 
 
 
AIM: 
To study and implement the basic UNIX commands. 
 
 
1. DISPLAY COMMANDS 
a) date – used to check the date and time Syntax: $ date 
Format Purpose Example Result 
+ % m To display only month $ date + % m 
+ % h To display month name $ date + % h 
+ % d To display day of month $ date + % d 
+ % y To display last two digits of the year $ date + % y 
+ % H To display hours $ date + % H 
+ % M To display minutes $ date + % M 
+ % S To display seconds $ date + % S 
 
 
b) cal – used to display the 
calendar Syntax: $ cal 2 2009 
 
c) echo – used to print the message on the screen. 
Syntax: $ echo “text” 
 
d) ls – used to list the files. Yourfiles are kept in a directory. 
Syntax: $ ls 
ls – s All files (include files with . prefix) ls – l Long detail (provide file statistics) ls – t Order 
by creation time 
ls – u Sort by access time (or show when last accessed together with –l) ls – s Order by size 
ls – r Reverse order 
ls – f Mark directories with / ,executable with * , symbolic links with @ , local sockets with = 
, named pipes (FIFOs) with | 
ls – s Show file size 
ls – h “Human Readable”, show file size in Kilo Bytes & Mega Bytes (h can be used together 
with –l or-s) 
21PD03-OPERATING SYSTEMS 
717822P321 2 
 
 
 
 
ls [a-m]* List all the files whose name begin with alphabets From “a” to “m” ls [a]*List all the 
files whose name begins with “a” or “A”. 
Eg: $ ls > mylist 
Output of “ls” command is stored to disk file named “my list”. 
e) lp – used to take printouts 
Syntax: $ lp filename 
 
f) man – used to provide manual help on every UNIX commands. 
Syntax: $ man unixcommand 
$ man cat 
 
 
g) who & who am i – it displays data about all users who have logged in to the system 
currently. The next command displays about current user only. 
Syntax: $ who 
Syntax :$ who am i 
 
h) uptime – tells you how long the computer has been running since its last re boot orpower- 
off. 
Syntax: $ uptime 
 
 
i) uname – it displays the system information such as hardware platform, system name and 
processor,OS type. 
Syntax: $ uname –a 
 
 
j) hostname – displays and set system host name Syntax :$ hostname 
 
 
k) bc – stands for “best calcualtor‟ Syntax:$ bc 
 
 
2. FILE MANIPULATION COMMANDS 
 
 
a) cat – this create, view and concatenate files. 
Creation: 
Syntax: $ cat > filename 
Viewing: 
21PD03-OPERATING SYSTEMS 
717822P321 3 
 
 
 
 
Syn: $ cat filename 
Add text to an existing file: 
Syntax: $ cat >> filename 
Concatenate: 
Syntax: $ cat file1 file2 > file3 
$ cat file1 file2 >> file3 (no overwriting of file3) 
 
 
b) grep – used to search a particular word or pattern related to that word from the file. Syntax: 
$ grep searchword filename 
Eg: $ grep anu student 
 
c) rm – deletes a filefrom the filesystem 
Syntax: $ rm filename 
 
d) touch – used to create a blank file. 
Syntax: $ touch file names 
 
 
e) cp – copies the files or directories 
Syntax: $ cp source filedestination file 
eg: $ cp student stud 
 
f) mv – to rename the fileor directory 
Syntax: $ mv old file new file 
Eg: $ mv –i student student list (-i prompt when overwrite) 
 
 
g) cut – it cuts or pick up a given number of character or fields of the file. 
Syntax: $ cut <option> <filename> 
Eg: $ cut –c filename 
$ cut –c 1 -10 emp 
$ cut –f 3,6 emp 
$ cut –f 3-6 emp 
 
 
h) head – displays 10 lines from the head (top) of a given file 
Syntax: $ head filename 
21PD03-OPERATING SYSTEMS 
717822P321 4 
 
 
 
 
eg: $ head student 
To display the top two lines: 
$ head -2 student 
 
 
i) tail – displays last 10 lines of the file 
Syntax: $ tail filename 
eg: $ tail student 
To display the bottom two lines; 
$ tail -2 student 
 
 
k)wc – it counts the number of lines, words, character in a specified file(s) with the 
options as – l, -w, -c 
Syntax: $wc –l filename 
$wc –w filename 
$wc –c filename 
 
 
3. DIRECTORY COMMANDS 
a) mkdir – used for creating a directory. 
Syntax: $ mkdir <directory name> 
 
b) rmdir– it is an utility for deletingemptydirectories. 
Syntax: $ rmdir directory name 
 
 
c) cd – changes the current directory of the shell. 
Syn: $ cd ~ 
(stores the path to your home directory) 
$ cd.. 
(changes to parent directory) 
$ cd 
 
 
d) pwd – (PrintWorking Directory) shows the current directory. Syntax: $ pwd 
 
 
4. PROCESS COMMANDS 
a) exit – terminates a process 
21PD03-OPERATING SYSTEMS 
717822P321 5 
 
 
 
 
Syntax: $ exit 
b) kill – terminates or send a signal to process 
Syntax: $ kill 
 
c) passwd – create or change a password 
Syntax: $ passwd 
 
d) telnet – connect to remote machine using the telnet protocol 
Syntax: $ telnet 
GROUPING COMMANDS 
a) Thesemicolon (;) - used ot execute more than one command at a time 
eg: $ who ; date ; ls 
 
b) The && operator – signifies the logical AND operation. It means that only if first command 
is successfully executed, then the nest command will be executed. 
c) The || operator – signifies the logical OR operation. It means the first command will 
happen to be unsuccessful, it will continue to execute next command. 
Eg: $ ls marks || date 
 
OUTPUT: 
 
21PD03-OPERATING SYSTEMS 
717822P321 6 
 
 
 
 
 
21PD03-OPERATING SYSTEMS 
717822P321 7 
 
 
 
 
 
 
 
21PD03-OPERATING SYSTEMS 
717822P321 8 
 
 
 
 
 
 
 
 
 
 
 
PREPARATION 30 
 
LAB PERFORMANCE 30 
 
REPORT 40 
 
TOTAL 100 
 
INITIAL OF THE FACULTY 
 
 
 
 
RESULT: 
Thus the program tostudy and implement the basic UNIX commands was executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 9 
 
 
 
 
Ex no : 2A  
SHELL PROGRAM USING BASIC TESTS Date :26/02/24 
 
AIM: 
To write a shell program to find whether a number is even or odd using testing. 
 
ALGORITHM: 
 
Step 1: Start the program. 
Step 2: Readtheinputnumber. 
Step 3: Perform modular division on input number by 2 and store the remainder using 
variable. 
Step 4: Open “if” statement. 
 
Step 5: If the remainder is 0 then print the number is even. 
Step 6: Else print number is odd. 
Step 7: Close if using “fi” statement. 
Step 8: Stop the program. 
PROGRAM: 
 
echo "Enter the Number" 
r=`expr $n % 2` 
if [ $r -eq 0 ] 
then. 
echo "$n is Even number" 
else. 
echo "$n is Odd number" 
fi. 
 
OUTPUT: 
 
 
 
 
RESULT: 
Thus the program to write a shell program to find whether a number is even or odd using testing 
executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 10 
 
 
 
Ex no : 2B  
SHELL PROGRAM USING LOOPS Date : 26/02/24 
 
AIM: 
To write a shell program for finding a factorial of a number using while loop. 
 
ALGORITHM: 
Step 1: Start the program. 
Step 2: Read a number. 
Step 3: Initialize fact as 1. 
Step 4: Initialize I as 1. 
Step 5: Check while I is lesser than or equal to number. 
Step 6: Multiplythevalueof I and fact and assign to fact incrementthevalueof I by 1. 
Step 7: Print the result. 
Step 8: Stop the program. 
 
 
PROGRAM: 
echo "Enter a number" 
read num 
fact=1 
while [ $num -gt 1 ] 
do 
fact=`expr $fact \* $num` 
num=`expr $num - 1` 
done 
echo $fact 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
RESULT: 
Thus the program to write a shell program for finding a factorial of a number using while loop 
executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 11 
 
 
 
Ex no : 2C  
SHELLPROGRAM USING PATTERN Date : 04/03/24 
 
 
AIM: 
To write a simple shell program for menu driven calculator using pattern. 
 
ALGORITHM: 
Step 1: Start the program. 
Step 2: Initializesum is equal to 0 and i is equal to y. 
Step 3: Read the values a and b. 
Step 4: Checkwhetherwhileisequalto y. 
Step 5: Print thecalculator options. 
Step 6: Read thechoice of operation. 
Step 7: Open the case statement. 
Step 8: Performthevariousoperationusingexpr. 
Step 9: Print thecorresponding result. 
Step 10: Close thecase statement. 
Step 11: Read the i value. 
Step 12: If i isnot equal to ythen exitoperation is performed. 
Step 13: Stop the program. 
 
PROGRAM: 
 
echo "ENTER 1st NUMBER:" 
read a 
echo "ENTER 2nd NUMBER:" 
read b 
i=1 
while [ $i -eq 1 ]; do 
echo "!!!MENU!!!" 
echo "1.ADDITION OF $a AND $b" 
echo "2.SUBTRACTION OF $a AND $b" 
echo "3.MULTIPLICATION OF $a AND $b" 
echo "4.DIVISION OF $a AND $b" 
echo "5.EXPONENTIAL FUNCTION $a^$b" 
echo "6.EXIT" 
echo "ENTER YOUR CHOICE:" 
read choice 
case $choice in 
1) 
sum=`expr $a + $b` 
echo "SUM: $sum" 
;; 
2) 
diff=`expr $a - $b` 
echo "DIFFERENCE: $diff" 
21PD03-OPERATING SYSTEMS 
717822P321 12 
 
 
 
3) 
 
 
4) 
 
 
5) 
 
 
 
 
6) 
*) 
esac 
;; 
 
pro=`expr $a \* $b` 
echo "PRODUCT: $pro" 
;; 
 
echo "DIVISION: $(echo "scale=2; $a/$b" | bc)" 
;; 
 
exp=1 
for (( i=1 ; i <= b ; i++ )); do 
exp=`expr $a \* $exp` 
done 
;; 
 
break 
;; 
 
echo "WRONG ENTRY" 
;; 
echo "$a^$b = $exp" 
done 
echo "PRESS 1 TO CONTINUE:" 
read i 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESULT: 
Thus the program to write a simple shell program for menu driven calculator using pattern was 
executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 13 
 
 
 
Ex no : 2D  
SHELLPROGRAM USING SUBSTITUTION Date : 04/03/24 
 
AIM: 
 
To perform substitution when it encounters an expression that contains one or more special 
characters. 
 
EXAMPLE: 
The printing value of thevariableissubstituted by itsvalue. Same time, "\n" is substituted by a 
new line − 
#!/bin/sh 
a=10 
echo -e "Value of a is $a \n" 
Youwillreceive the followingresult. Here the -e option enables the interpretation of backslash 
escapes. 
Value of a is 10 
Following is the result without -e option − 
Value of a is 10\n 
Here are following escape sequences which can be used in echo command − 
 
S.No. Escape & Description 
1 \\ 
Backslash 
2 \a 
alert (BEL) 
3 \b 
Backspace 
4 \c 
suppress trailing newline 
5 \f 
form feed 
6 \n 
new line 
7 \r 
carriage return 
8 \t 
horizontal tab 
9 \v 
vertical tab 
Use the -E option to disable the interpretation of the backslash escapes (default). 
21PD03-OPERATING SYSTEMS 
717822P321 14 
 
 
 
Use the -n option to disable the insertion of a new line. 
Command Substitution: 
Commandsubstitution is themechanismby whichthe shell performs a given set of commands and 
thensubstitutestheir output in theplace of thecommands. 
Syntax 
The command substitution is performed when a command is given as − 
 
`command` 
Example 
#!/bin/sh 
DATE=`date` 
echo "Date is $DATE" 
 
USERS=`who | wc -l` 
 
echo "Logged in user are $USERS" 
 
UP=`date ; uptime` 
echo "Uptime is $UP" 
Upon execution, you wil receive the following result − 
Variable Substitution: 
Variablesubstitution enables the shell programmer to manipulate the value of a variable based on 
its state.Here is the followingtable for all the possible substitutions − 
 
S.No. Form & Description 
1 ${var} 
Substitute the value of var. 
2 ${var:-word} 
If var is null or unset, word is substituted for var. The value of var does 
not change. 
3 ${var:=word} 
If var is null or unset, var is set to the value of word. 
4 ${var:?message} 
If var is null or unset, message is printed to standard error. This checks 
that variables are setcorrectly. 
5 ${var:+word} 
If var is set, word is substituted for var. The value of var does not change. 
21PD03-OPERATING SYSTEMS 
717822P321 15 
 
 
 
a=10 echo -e "Value of a is $a \n" 
Value of a is 10 
 
Command Substitution 
DATE=$(date) 
echo "Date is $DATE" 
USERS=$(who | wc -l) 
echo "Logged in users are $USERS" 
UP=$(date ; uptime) 
echo "Uptime is $UP" 
 
Variable Substitution 
echo ${var:-"word is not set"} 
echo "1 - Value of var is ${var}" 
echo ${var:="word is not set"} 
echo "2 - Value of var is ${var}" 
unset var; 
echo ${var:+"This is default value"} 
echo "3 - Value of var is $var" 
var="Prefix" 
echo ${var:+"This is default value"} 
echo "4 - Value of var is $var" 
echo ${var:?"Print this message"} 
echo "5 - Value of var is ${var}" 
 
Output: 
 
 
 
 
 
 
 
 
 
 
 
 
RESULT: 
Thus the program to perform substitution when it encounters an expression that contains one or more 
special characters was executed successfully. 
PREPARATION 30 
 
LAB PERFORMANCE 30 
 
REPORT 40 
 
TOTAL 100 
 
INITIAL OF THE FACULTY 
 
 
21PD03-OPERATING SYSTEMS 
717822P321 16 
 
 
 
Ex no : 3A  
FILE SYSTEM RELATED SYSTEM CALLS Date : 11/03/24 
 
AIM: 
To write a c program for file system related system calls with basic operations of file. 
 
ALGORITHM: 
Step 1: Start the program. 
Step 2: Create the file. 
Step 3: Perform the read operation 
Step 4: Check if the file is existing or not. 
Step 5: Create a file table entry and point the unused file descriptor to that created file. 
Step 6: Perform write operation 
Step 7: Close the program 
Step 8: Stop the program. 
 
PROGRAM: 
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <fcntl.h> 
#include<string.h> 
int main() { 
 
printf("Program started.\n"); 
char *filename = "exam.txt"; 
int fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0644); 
if (fd == -1) { 
perror("Error creating file"); 
return 1; 
} 
printf("File '%s' created.\n", filename); 
 
if (access(filename, F_OK) != -1) { 
printf("File '%s' exists.\n", filename); 
} else { 
printf("File '%s' does not exist.\n", filename); 
} 
printf("File descriptor %d points to file '%s'.\n", fd, filename); 
char *message = "Hello, world!\n"; 
if (write(fd, message, strlen(message)) == -1) { 
perror("Error writing to file"); 
return 1; 
} 
printf("Message '%s' written to file.\n", message); 
 
close(fd); 
printf("File descriptor %d closed.\n", fd); 
21PD03-OPERATING SYSTEMS 
717822P321 17 
 
 
printf("Program stopped.\n"); 
 
return 0; 
} 
 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESULT:  
Thus the program to write a c program for file system related system calls with basic 
operations of file was executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 18 
 
 
 
Ex no : 3B  
FILE SYSTEM RELATED SYSTEM CALLS Date : 11/03/24 
 
 
AIM: 
To write a c program for file system related system calls with basic operations of file. 
 
ALGORITHM: 
Step 1: Start the program. 
Step 2: Open the directory 
Step 3: Perform the read operation 
Step 4: Check if the file is existing or not. 
Step 5: Create a file table entry and point the unused file descriptor to that created file. 
Step 6: Give the file name as input with specification type. 
Step 7: Display the result. 
Step 8: Stop the program. 
 
PROGRAM: 
#include <stdio.h> 
#include <stdlib.h> 
#include <dirent.h> 
#include <unistd.h> 
#include <fcntl.h> 
#include <string.h> 
 
#define MAX_FILENAME_LENGTH 100 
 
int main() { 
 
printf("Program started.\n"); 
DIR *dir; 
struct dirent *entry; 
 
dir = opendir("."); 
if (dir == NULL) { 
perror("Error opening directory"); 
return 1; 
} 
printf("Contents of the directory:\n"); 
while ((entry = readdir(dir)) != NULL) { 
printf("%s\n", entry->d_name); 
} 
char filename[MAX_FILENAME_LENGTH]; 
printf("Enter the filename: "); 
scanf("%s", filename); 
 
if (access(filename, F_OK) != -1) { 
printf("File '%s' exists.\n", filename); 
21PD03-OPERATING SYSTEMS 
717822P321 19 
 
 
} else { 
printf("File '%s' does not exist.\n", filename); 
closedir(dir); 
return 1; 
} 
int fd = open(filename, O_RDONLY); 
if (fd == -1) { 
perror("Error opening file"); 
closedir(dir); 
return 1; 
} 
printf("File descriptor %d points to file '%s'.\n", fd, filename); 
char spec_type[MAX_FILENAME_LENGTH]; 
printf("Enter the specification type: "); 
scanf("%s", spec_type); 
printf("File name: %s, Specification type: %s\n", filename, spec_type); 
close(fd); 
closedir(dir); 
printf("Program stopped.\n"); 
 
return 0; 
} 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
 
RESULT: 
Thus the program to write a c program for file system related system calls with basic 
operations of file executed successfully. 
PREPARATION 30 
 
LAB PERFORMANCE 30 
 
REPORT 40 
 
TOTAL 100 
 
INITIAL OF THE FACULTY 
 
 
21PD03-OPERATING SYSTEMS 
717822P321 20 
 
 
 
Ex no : 4A  
PROCESS MANAGEMENT-FORK Date : 18/03/24 
 
Aim: 
To create a new child process using fork system call. 
 
 
Algorithm  
 
Step 1: Declare a variable x to be shared by both child and parent. 
Step 2:Create a child process using fork system call. 
Step 3:If return value is -1 
then Print "Process creation unsuccessfull" 
Terminate using exit system call. 
Step 4: If return value is 0 
then Print "Child process" 
Print process id of the child using getpid system call 
Print value of x 
Print process id of the parent using getppid system call 
Step 5: Otherwise Print "Parent process" 
Print process id of the parent using getpid system call 
Print value of x Print process id of the shell using getppid system call 
Step 6: Stop the program. 
 
PROGRAM: 
 
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/types.h> 
#include <unistd.h> 
void forkexample() 
{ 
pid_t p; 
p = fork(); 
if(p<0) 
{ 
perror("fork fail"); 
exit(1); 
} 
// child process because return value zero 
21PD03-OPERATING SYSTEMS 
717822P321 21 
 
 
 
 
 
else if ( p == 0) 
printf("Hello from Child!\n"); 
 
// parent process because return value non-zero. 
else 
printf("Hello from Parent!\n"); 
} 
int main() 
{ 
forkexample(); 
return 0; 
} 
 
 
 
 
 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESULT: 
Thus the program to create a new child process using fork system call executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 22 
 
 
 
Ex no : 4B  
PROCESS MANAGEMENT-EXEC SYSTEM CALL 
Date : 18/03/24 
 
Aim 
To load an executable program in a child processes exec system call. 
 
Algorithm 
 
 
Step 1:Start the Program 
Step 2: Create a child process using fork system call. 
Step 3: If return value is -1 then 
a. Print "Process creation unsuccessfull" 
Step 4:Terminate using exit system call. 
Step 5: If return value is > 0 then 
a. Suspend parent process until child completes using wait system call 
b. Print "Child Terminated". 
c. Terminate the parent process. 
Step 6:If return value is 0 then 
a. Print "Child starts" 
b. Load date program into child process using exec system call. 
c. Terminate the child process. 
Step 7:Stop the program. 
 
 
 
PROGRAM: 
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/types.h> 
#include <sys/wait.h> 
#include <unistd.h> 
 
int main() { 
pid_t pid = fork(); 
if (pid == -1) { 
printf("Process creation unsuccessful\n"); 
exit(EXIT_FAILURE); 
} else if (pid > 0) { 
21PD03-OPERATING SYSTEMS 
717822P321 23 
 
 
wait(NULL); 
printf("Child Terminated\n"); 
exit(EXIT_SUCCESS); 
} else { 
 
printf("Child starts\n"); 
execl("/bin/date", "date", NULL); 
perror("exec failed"); 
exit(EXIT_FAILURE); 
} 
 
 
} 
 
OUTPUT: 
return 0; 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PREPARATION 30 
 
LAB PERFORMANCE 30 
 
REPORT 40 
 
TOTAL 100 
 
INITIAL OF THE FACULTY 
 
 
RESULT: 
Thus the program to load an executable program in a child processes exec system call executed 
successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 24 
 
 
 
 
Ex no : 5  
INTER-PROCESS COMMUNICATION BETWEEN 
RELATED PROCESSES USING PIPES Date : 01/04/24 
 
AIM: 
To implement inter process communication using pipes. 
 
ALGORITHM: 
 
Step 1. Start the program 
 
Step 2. Create the child process using fork() 
Step 3. Create the pipe structure using pipe() 
Step 4. Now close theread end of the parent process usingclose() 
Step 5. Writethe data in the pipe usingwrite() 
Step 6. Now close thewriteend of childprocess usingclose() 
Step 7. Read the data in the pipe using read() 
Step 8. Display the string 
Step 9. Stop the program. 
 
PROGRAM: 
#include<stdio.h> 
#include<unistd.h> 
int main() { 
int pipefds[2]; 
int returnstatus; 
int pid; 
char writemessages[2][20]={"Hi", "Hello"}; 
char readmessage[20]; 
returnstatus = pipe(pipefds); 
if (returnstatus == -1) { 
printf("Unable to create pipe\n"); 
return 1; 
} 
pid = fork(); 
21PD03-OPERATING SYSTEMS 
717822P321 25 
 
 
 
// Child process 
if (pid == 0) { 
read(pipefds[0], readmessage, sizeof(readmessage)); 
printf("Child Process - Reading from pipe – Message 1 is %s\n", readmessage); 
read(pipefds[0], readmessage, sizeof(readmessage)); 
printf("Child Process - Reading from pipe – Message 2 is %s\n", readmessage); 
} else { //Parent process 
printf("Parent Process - Writing to pipe - Message 1 is %s\n", 
writemessages[0]); 
write(pipefds[1], writemessages[0], sizeof(writemessages[0])); 
printf("Parent Process - Writing to pipe - Message 2 is %s\n", 
writemessages[1]); 
write(pipefds[1], writemessages[1], sizeof(writemessages[1])); 
} 
return 0; 
} 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PREPARATION 30 
 
LAB PERFORMANCE 30 
 
REPORT 40 
 
TOTAL 100 
 
INITIAL OF THE FACULTY 
 
 
RESULT: 
Thus the program to implement inter process communication using pipes executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 26 
 
 
 
Ex no : 6 INTER-PROCESS COMMUNICATION AMONG UNRELATED 
PROCESSES USING MESSAGE QUEUE Date : 08/04/24 
 
AIM: 
To Write a c program to implement inter process communication among unrelated processes 
using message queue 
ALGORITHM: 
 
Step 1. Start the program 
 
Step 2: Create a message queue . 
 
Step 3. Connect it to the already existing 
message. 
Step 4. Write into message queue (msgsnd()) 
Step 5. Read from the message queue (msgrcv()) 
Step 6. Perform control operations on the message queue (msgctl() 
Step 7. Send the received Acknowledgment. 
Step 8. Display the string 
Step 9. Stop the program. 
 
PROGRAM: 
// C Program for Message Queue (Writer Process) 
#include <stdio.h> 
#include <sys/ipc.h> 
#include <sys/msg.h> 
#define MAX 10 
 
// structure for message queue 
struct mesg_buffer { 
long mesg_type; 
char mesg_text[100]; 
} message; 
 
int main() 
{ 
key_t key; 
int msgid; 
21PD03-OPERATING SYSTEMS 
717822P321 27 
 
 
 
// ftok to generate unique key 
key = ftok("progfile", 65); 
 
// msgget creates a message queue 
// and returns identifier 
msgid = msgget(key, 0666 | IPC_CREAT); 
message.mesg_type = 1; 
 
printf("Write Data : "); 
fgets(message.mesg_text,MAX,stdin); 
 
// msgsnd to send message 
msgsnd(msgid, &message, sizeof(message), 0); 
 
// display the message 
printf("Data send is : %s \n", message.mesg_text); 
 
return 0; 
} 
// C Program for Message Queue (Reader Process) 
#include <stdio.h> 
#include <sys/ipc.h> 
#include <sys/msg.h> 
 
// structure for message queue 
struct mesg_buffer { 
long mesg_type; 
char mesg_text[100]; 
} message; 
 
int main() 
{ 
key_t key; 
int msgid; 
 
// ftok to generate unique key 
key = ftok("progfile", 65); 
 
// msgget creates a message queue 
// and returns identifier 
msgid = msgget(key, 0666 | IPC_CREAT); 
 
// msgrcv to receive message 
msgrcv(msgid, &message, sizeof(message), 1, 0); 
 
// display the message 
printf("Data Received is : %s \n", 
message.mesg_text); 
 
// to destroy the message queue 
msgctl(msgid, IPC_RMID, NULL); 
 
return 0; 
} 
OUTPUT: 
21PD03-OPERATING SYSTEMS 
Thus the above program to implement inter process communication among unrelated 
processes using message queue executed successfully. 
PREPARATION 
30 
LAB PERFORMANCE 
REPORT 
30 
40 
TOTAL 
100 
INITIAL OF THE FACULTY 
RESULT: 
28 
717822P321 
21PD03-OPERATING SYSTEMS 
717822P321 29 
 
 
 
Ex no : 7A  
CPU SCHEDULING ALGORITHMS 
Date : 22/04/24 
 
AIM: 
To write a C program to perform SJF scheduling algorithm. 
 
 
ALGORITHM: 
Step 1: Start the program. 
Step 2: Read thenumber of requests. 
Step 3: Input theprocesses alongwiththeirburst time (bt). 
Step 4: Sort all theprocesses in increasing order according to burst time.( (i.e. the job 
having least burst time is executed first). 
Step 5: Print theorder in whichprocess gets executed. 
Step 6: Find waiting time(wt) for all processes. 
Step 7: As firstprocess that comes need not to waitso waitingtimefor process 1 willbe 0 
i.e. wt[0] = 0. 
Step 8: Findwaitingtimeforallother processes i.e. for 
process i -> wt[i] = bt[i-1] + wt[i-1] . 
Step 9: Findturnaround time= waiting_time + burst_timefor allprocesses. 
Step 10: Find averagewaiting time= total_waiting_time /no_of_processes. 
Step 11: Find averageturnaround time= total_turn_around_time / no_of_processes. 
Step 12: The gantt chart is drawn representing theprocess execution. 
Step 13: Stop the process. 
 
 
PROGRAM: 
 
#include<stdio.h> 
 
void calculate_waiting_time(int processes[], int n, int burst_time[], int waiting_time[]) { 
// Waiting time for first process is 0 
waiting_time[0] = 0; 
 
// Calculate waiting time for each process 
for (int i = 1; i < n; i++) { 
waiting_time[i] = burst_time[i - 1] + waiting_time[i - 1]; 
} 
} 
 
void calculate_turnaround_time(int processes[], int n, int burst_time[], int waiting_time[], 
21PD03-OPERATING SYSTEMS 
717822P321 30 
 
 
int turnaround_time[]) { 
// Calculate turnaround time for each process 
for (int i = 0; i < n; i++) { 
turnaround_time[i] = burst_time[i] + waiting_time[i]; 
} 
} 
 
void calculate_average_times(int processes[], int n, int burst_time[]) { 
int waiting_time[n], turnaround_time[n]; 
int total_waiting_time = 0, total_turnaround_time = 0; 
 
calculate_waiting_time(processes, n, burst_time, waiting_time); 
calculate_turnaround_time(processes, n, burst_time, waiting_time, turnaround_time); 
 
printf("Process\t Burst Time\t Waiting Time\t Turnaround Time\n"); 
for (int i = 0; i < n; i++) { 
printf("P%d\t\t%d\t\t%d\t\t%d\n", i + 1, burst_time[i], waiting_time[i], 
turnaround_time[i]); 
total_waiting_time += waiting_time[i]; 
total_turnaround_time += turnaround_time[i]; 
} 
 
double average_waiting_time = (double)total_waiting_time / n; 
double average_turnaround_time = (double)total_turnaround_time / n; 
 
printf("\nAverage Waiting Time: %.2lf\n", average_waiting_time); 
printf("Average Turnaround Time: %.2lf\n", average_turnaround_time); 
} 
 
void sjf_scheduling(int processes[], int n, int burst_time[]) { 
// Sort processes based on burst time (SJF) 
for (int i = 0; i < n - 1; i++) { 
for (int j = 0; j < n - i - 1; j++) { 
if (burst_time[j] > burst_time[j + 1]) { 
// Swap burst time 
int temp = burst_time[j]; 
burst_time[j] = burst_time[j + 1]; 
burst_time[j + 1] = temp; 
 
// Swap process IDs 
temp = processes[j]; 
processes[j] = processes[j + 1]; 
processes[j + 1] = temp; 
} 
} 
} 
calculate_average_times(processes, n, burst_time); 
} 
21PD03-OPERATING SYSTEMS 
717822P321 31 
 
 
 
 
int main() { 
// Input: List of processes with their burst time 
int processes[] = {1, 2, 3, 4}; 
int burst_time[] = {6, 8, 7, 3}; 
int n = sizeof(processes) / sizeof(processes[0]); 
sjf_scheduling(processes, n, burst_time); 
return 0; 
} 
 
 
 
 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESULT: 
Thus the program to write a C program to perform SJF scheduling algorithm executed 
successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 32 
 
 
Ex no : 7B  
IMPLEMENTATION OF FCFS SCHEDULING ALGORITHM Date : 22/04/24 
 
AIM: 
To write a C program to perform FCFS Scheduling algorithm. 
 
 
ALGORITHM: 
 
Step 1: Start the program. 
Step 2: Read thenumber of requests. 
Step 3: Input theprocesses alongwiththeir burst time(bt). 
Step 4: Find waiting time (wt) for all processes. 
Step 5: As firstprocess that comes need not to waitso waitingtimefor process 1 willbe 0 
i.e. wt[0] = 0. 
Step 6: Findwaitingtimeforallother processes i.e. for 
process i -> wt[i] = bt[i-1] + wt[i-1] . 
Step 7: Findturnaround time= waiting_time + burst_timefor allprocesses. 
Step 8: Find averagewaiting time= total_waiting_time /no_of_processes. 
Step 9: Find averageturnaround time= total_turn_around_time / no_of_processes. 
Step 10: The gantt chart is drawn representing theprocess execution. 
Step 11: Stop the process. 
 
 
 
PROGRAM: 
 
#include <stdio.h> 
void calculate_waiting_time(int processes[], int n, int bt[], int wt[]) { 
// Waiting time for the first process is 0 
wt[0] = 0; 
// Calculate waiting time for each process 
for (int i = 1; i < n; i++) 
wt[i] = bt[i - 1] + wt[i - 1]; 
} 
void calculate_turnaround_time(int processes[], int n, int bt[], int wt[], int tat[]) { 
// Calculate turnaround time for each process 
for (int i = 0; i < n; i++) 
tat[i] = bt[i] + wt[i]; 
} 
void fcfs_scheduling(int processes[], int n, int bt[]) { 
int wt[n], tat[n]; 
// Calculate waiting time and turnaround time 
calculate_waiting_time(processes, n, bt, wt); 
calculate_turnaround_time(processes, n, bt, wt, tat); 
21PD03-OPERATING SYSTEMS 
717822P321 33 
 
 
// Print results 
printf("Process\tBurst Time\tWaiting Time\tTurnaround Time\n"); 
for (int i = 0; i < n; i++) 
printf("%d\t%d\t\t%d\t\t%d\n", processes[i], bt[i], wt[i], tat[i]); 
// Calculate average waiting time 
float total_wt = 0; 
for (int i = 0; i < n; i++) 
total_wt += wt[i]; 
float avg_wt = total_wt / n; 
 
// Calculate average turnaround time 
float total_tat = 0; 
for (int i = 0; i < n; i++) 
total_tat += tat[i]; 
float avg_tat = total_tat / n; 
printf("\nAverage Waiting Time: %.2f\n", avg_wt); 
printf("Average Turnaround Time: %.2f\n", avg_tat); 
} 
int main() { 
// Number of processes 
int n; 
printf("Enter the number of processes: "); 
scanf("%d", &n); 
// Burst time for each process 
int burst_time[n]; 
printf("Enter burst time for each process:\n"); 
for (int i = 0; i < n; i++) { 
printf("P[%d]: ", i + 1); 
scanf("%d", &burst_time[i]); 
 
 
 
 
 
 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
 
 
RESULT: 
} 
// Process IDs 
int processes[n]; 
for (int i = 0; i < n; i++) 
processes[i] = i + 1; 
// Perform FCFS scheduling 
fcfs_scheduling(processes, n, burst_time); 
return 0; 
 
 
 
 
 
Thus the program to write a C program to perform FCFS Scheduling algorithm 
executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 34 
 
 
 
Ex no : 7C  
IMPLEMENTATION OF PRIORITY SCHEDULING ALGORITHM Date : 22/04/24 
 
AIM: 
To write a C program to implement the priority scheduling algorithm. 
 
ALGORITHM: 
Step 1:  Start the program. 
Step 2:  Read the number of requests. 
Step 3: Input the processes along with their burst time (bt) and priority. 
Step 4: Sort theprocesses, burst timeand priorityaccording to thepriority. 
Step 5: Print the order in which process gets executed. 
Step 6:  Findwaitingtime(wt) for all processes. 
Step 7: As firstprocess that comes need not to wait so waitingtimefor process 1 willbe 0 
i.e. wt[0] = 0. 
Step 8: Findwaiting time for allother processes i.e. for 
process i -> wt[i] = bt[i-1] + wt[i-1] . 
Step 9: Findturnaround time= waiting_time + burst_timefor allprocesses. 
Step 10: Find averagewaiting time= total_waiting_time /no_of_processes. 
Step 11: Find averageturnaround time= total_turn_around_time / no_of_processes. 
Step 12: The gantt chart is drawn representing theprocess execution. 
Step 13: Stop the process. 
 
 
PROGRAM: 
 
#include <stdio.h> 
 
void calculate_waiting_time(int n, int burst_time[], int waiting_time[], int priority[]) { 
waiting_time[0] = 0; 
 
// Calculate waiting time for each process 
for (int i = 1; i < n; i++) { 
waiting_time[i] = burst_time[i - 1] + waiting_time[i - 1]; 
} 
} 
 
void calculate_turnaround_time(int n, int burst_time[], int waiting_time[], int 
turnaround_time[]) { 
// Calculate turnaround time for each process 
for (int i = 0; i < n; i++) { 
turnaround_time[i] = burst_time[i] + waiting_time[i]; 
} 
} 
21PD03-OPERATING SYSTEMS 
717822P321 35 
 
 
 
void calculate_average_times(int n, int waiting_time[], int turnaround_time[]) { 
int total_waiting_time = 0, total_turnaround_time = 0; 
 
printf("Process\t Waiting Time\t Turnaround Time\n"); 
for (int i = 0; i < n; i++) { 
printf("P%d\t\t%d\t\t%d\n", i + 1, waiting_time[i], turnaround_time[i]); 
total_waiting_time += waiting_time[i]; 
total_turnaround_time += turnaround_time[i]; 
} 
 
double average_waiting_time = (double)total_waiting_time / n; 
double average_turnaround_time = (double)total_turnaround_time / n; 
 
printf("\nAverage Waiting Time: %.2lf\n", average_waiting_time); 
printf("Average Turnaround Time: %.2lf\n", average_turnaround_time); 
} 
 
void priority_scheduling(int n, int burst_time[], int priority[]) { 
int waiting_time[n], turnaround_time[n]; 
 
calculate_waiting_time(n, burst_time, waiting_time, priority); 
calculate_turnaround_time(n, burst_time, waiting_time, turnaround_time); 
 
calculate_average_times(n, waiting_time, turnaround_time); 
} 
 
int main() { 
// Input: List of processes with their burst time and priority 
int n = 4; 
int burst_time[] = {6, 8, 7, 3}; 
int priority[] = {2, 1, 4, 3}; 
priority_scheduling(n, burst_time, priority); 
return 0; 
} 
 
OUTPUT: 
 
 
 
 
 
RESULT: 
Thus the program to write a C program to implement the priority scheduling algorithm executed 
successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 36 
 
 
 
 
 
Ex no : 7D  
IMPLEMENTATION OF ROUND ROBIN ALGORITHM Date : 22/04/24 
AIM: 
To write a C program to implement the round robin algorithm 
 
 
ALGORITHM: 
 
Step 1: Start the program. 
Step 2: Read thenumber of process. 
Step 3: Inputtheprocesses alongwiththeirburst time(bt) andtime quantum. 
Step 4: Find waiting time (wt) for all processes. 
Step 5: Create an arrayrem_bt[] to keep track of remaining burst timeof processes. This 
array is initially a copy of bt[] (burst times array). 
Step 6: Create another arraywt[] to storewaitingtimes.Initialize thisarray as 0. 
Step 7: Initialize time : t = 0 
Keep traversing the all processes while all processes are not done. 
Do following for i'th process if it is not done yet. 
a- If rem_bt[i] > quantum 
(i) t = t + quantum 
(i) bt_rem[i] - = quantum; 
c- Else// Last cycleforthisprocess. 
(i) t = t + bt_rem[i]; 
(i) wt[i] = t - bt[i] 
(ii) bt_rem[i] = 0; // This process is over 
Step 8: Findturnaround time= waiting_time + burst_timefor allprocesses. 
Step 9: Find average waiting time= total_waiting_time /no_of_processes. 
Step 10: Find averageturnaroundtime= total_turn_around_time / no_of_processes. 
Step 11: The gantt chart is drawn representing theprocess execution. 
Step 12: Stop the process. 
21PD03-OPERATING SYSTEMS 
717822P321 37 
 
 
 
 
PROGRAM: 
 
#include <stdio.h> 
 
// Function to calculate waiting time for each process 
void calculate_waiting_time(int n, int burst_time[], int waiting_time[], int quantum) { 
int remaining_burst_time[n]; 
for (int i = 0; i < n; i++) { 
remaining_burst_time[i] = burst_time[i]; 
} 
 
int time = 0; 
while (1) { 
int done = 1; 
for (int i = 0; i < n; i++) { 
if (remaining_burst_time[i] > 0) { 
done = 0; // There is still pending process 
if (remaining_burst_time[i] > quantum) { 
time += quantum; 
remaining_burst_time[i] -= quantum; 
} else { 
time += remaining_burst_time[i]; 
waiting_time[i] = time - burst_time[i]; 
remaining_burst_time[i] = 0; 
} 
} 
} 
if (done == 1) { 
break; // All processes are executed 
} 
} 
} 
 
// Function to calculate turnaround time for each process 
void calculate_turnaround_time(int n, int burst_time[], int waiting_time[], int turnaround_time[]) { 
for (int i = 0; i < n; i++) { 
turnaround_time[i] = burst_time[i] + waiting_time[i]; 
} 
} 
 
// Function to calculate average waiting time and turnaround time 
void calculate_average_times(int n, int waiting_time[], int turnaround_time[]) { 
double total_waiting_time = 0, total_turnaround_time = 0; 
 
printf("Process\t Waiting Time\t Turnaround Time\n"); 
for (int i = 0; i < n; i++) { 
printf("P%d\t\t%d\t\t%d\n", i + 1, waiting_time[i], turnaround_time[i]); 
total_waiting_time += waiting_time[i]; 
total_turnaround_time += turnaround_time[i]; 
} 
 
double average_waiting_time = total_waiting_time / n; 
double average_turnaround_time = total_turnaround_time / n; 
21PD03-OPERATING SYSTEMS 
717822P321 38 
 
 
 
printf("\nAverage Waiting Time: %.2lf\n", average_waiting_time); 
printf("Average Turnaround Time: %.2lf\n", average_turnaround_time); 
} 
 
// Function to perform Round Robin scheduling 
void round_robin_scheduling(int n, int burst_time[], int quantum) { 
int waiting_time[n], turnaround_time[n]; 
 
calculate_waiting_time(n, burst_time, waiting_time, quantum); 
calculate_turnaround_time(n, burst_time, waiting_time, turnaround_time); 
 
calculate_average_times(n, waiting_time, turnaround_time); 
} 
 
int main() { 
// Input: List of processes with their burst time 
int n = 4; 
int burst_time[] = {5, 10, 15, 7}; 
int quantum = 3; 
 
round_robin_scheduling(n, burst_time, quantum); 
 
return 0; 
} 
 
 
 
 
 
OUTPUT: 
 
 
 
 
PREPARATION 30 
 
LAB PERFORMANCE 30 
 
REPORT 40 
 
TOTAL 100 
 
INITIAL OF THE FACULTY 
 
RESULT: 
 
Thus the program to write a C program to implement the round robin algorithm was executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 39 
 
 
 
Ex no : 8A  
IMPLEMENTATION OF MEMORY MANAGEMENT SCHEME USING 
FIRST FIT Date : 29/04/24 
 
 
AIM: 
To write a C program to implement dynamic memory allocation using first fit algorithm. 
 
ALGORITHM: 
Step 1: Start the program. 
Step 2: Input memoryblocks withsizeand processes withsize.Step 
Step 3: Initialize all memory blocks as free. 
Step 4: Start by picking each process and check if it can be assigned to current block. Step 
Step 5: If size-of-process < = size-of-block if yes then assign and check for next process. 
Step 6: If not then keep checking the further blocks. 
Step 7: Stop the program 
 
PROGRAM: 
#include <stdio.h> 
 
#define MEMORY_SIZE 1000 
 
// Structure to represent a memory block struct MemoryBlock { 
int start_address; int size; 
int allocated; 
}; 
 
// Function to initialize the memory blocks 
void initialize_memory(struct MemoryBlock memory[], int n) { for (int i = 0; i < n; i++) { 
memory[i].start_address = -1; // Indicates memory block is free memory[i].size = 0; 
memory[i].allocated = 0; 
} 
} 
 
// Function to allocate memory using First Fit algorithm 
void first_fit_allocation(struct MemoryBlock memory[], int n, int process_id, int size) { for (int i 
= 0; i < n; i++) { 
if (memory[i].allocated == 0 && memory[i].size >= size) { 
// Allocate memory 
21PD03-OPERATING SYSTEMS 
717822P321 40 
 
 
memory[i].allocated = 1; 
printf("Process P%d allocated at memory block %d, size %d\n", process_id, 
memory[i].start_address, size); 
memory[i].size -= size; return; 
} 
} 
printf("Process P%d cannot be allocated due to insufficient memory\n", process_id); 
} 
 
// Function to deallocate memory 
void deallocate_memory(struct MemoryBlock memory[], int n, int process_id) { for 
(int i = 0; i < n; i++) { 
if (memory[i].allocated == 1 && memory[i].start_address == process_id) { memory[i].allocated 
= 0; // Free memory block 
printf("Memory block allocated to Process P%d is deallocated\n", process_id); return; 
} 
} 
printf("Process P%d not found or already deallocated\n", process_id); 
} 
 
// Function to display memory status 
void display_memory_status(struct MemoryBlock memory[], int n) { 
printf("\nMemory Status:\n"); 
printf("Memory Block\t\tAllocated\tSize\n"); for 
(int i = 0; i < n; i++) { 
printf("%d\t\t\t", i); 
if (memory[i].allocated == 1) { printf("Yes\t\t%d\n", 
memory[i].size); 
} else { 
printf("No\t\t%d\n", memory[i].size); 
} 
} 
} 
 
int main() { 
// Initialize memory blocks 
int n = 5; // Number of memory blocks struct 
MemoryBlock memory[n]; 
initialize_memory(memory, n); 
 
// Allocate memory to processes 
first_fit_allocation(memory, n, 1, 200); 
first_fit_allocation(memory, n, 2, 300); 
first_fit_allocation(memory, n, 3, 150); 
first_fit_allocation(memory, n, 4, 400); 
 
// Display memory status after allocation 
display_memory_status(memory, n); 
 
// Deallocate memory 
deallocate_memory(memory, n, 2); 
 
// Display memory status after deallocation 
21PD03-OPERATING SYSTEMS 
717822P321 41 
 
 
display_memory_status(memory, n); 
 
return 0; 
} 
 
 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESULT: 
Thus the program to implement dynamic memory allocation using first fit algorithm executed 
successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 42 
 
 
Ex no : 8B IMPLEMENTATION OF MEMORY MANAGEMENT SCHEME USING 
BEST FIT Date : 29/04/24 
 
AIM: 
To write a C program to implement dynamic memory allocation using best fit algorithm. 
 
ALGORITHM: 
 
Step 1: Start the program. 
Step 2: Input memoryblocks and processes withsizes. 
Step 3: Initializeallmemoryblocks as free. 
Step 4: Start by picking each process and find the minimum block size that can be assigned 
to current process i.e., find min(bockSize[1],blockSize[2], blockSize[n]) > 
processSize[current]. 
Step 5: If foundthen assign it to thecurrent process. 
Step 6: If not then leavethat process and keep checkingthefurther processes. 
Step 7: Stop the program. 
 
 
PROGRAM: 
 
#include <stdio.h> 
 
#define MEMORY_SIZE 1000 
 
// Structure to represent a memory block 
struct MemoryBlock { 
int start_address; int 
size; 
int allocated; 
}; 
 
// Function to initialize the memory blocks 
void initialize_memory(struct MemoryBlock memory[], int n) { 
for (int i = 0; i < n; i++) { 
memory[i].start_address = -1; // Indicates memory block is free 
memory[i].size = 0; 
memory[i].allocated = 0; 
} 
} 
 
// Function to allocate memory using Best Fit algorithm 
void best_fit_allocation(struct MemoryBlock memory[], int n, int process_id, int size) { 
21PD03-OPERATING SYSTEMS 
717822P321 43 
 
 
int best_fit_index = -1; 
int min_fragmentation = MEMORY_SIZE + 1; 
 
for (int i = 0; i < n; i++) { 
if (memory[i].allocated == 0 && memory[i].size >= size) { int 
fragmentation = memory[i].size - size; 
if (fragmentation < min_fragmentation) { min_fragmentation 
= fragmentation; best_fit_index = i; 
} 
} 
} 
 
if (best_fit_index != -1) { 
// Allocate memory 
memory[best_fit_index].allocated = 1; 
printf("Process P%d allocated at memory block %d, size %d\n", process_id, 
memory[best_fit_index].start_address, size); 
memory[best_fit_index].size -= size; 
} else { 
printf("Process P%d cannot be allocated due to insufficient memory\n", process_id); 
} 
} 
 
// Function to deallocate memory 
void deallocate_memory(struct MemoryBlock memory[], int n, int process_id) { 
for (int i = 0; i < n; i++) { 
if (memory[i].allocated == 1 && memory[i].start_address == process_id) { memory[i].allocated = 0; 
// Free memory block 
printf("Memory block allocated to Process P%d is deallocated\n", process_id); return; 
} 
} 
printf("Process P%d not found or already deallocated\n", process_id); 
} 
 
// Function to display memory status 
void display_memory_status(struct MemoryBlock memory[], int n) { 
printf("\nMemory Status:\n"); 
printf("Memory Block\t\tAllocated\tSize\n"); for 
(int i = 0; i < n; i++) { 
printf("%d\t\t\t", i); 
if (memory[i].allocated == 1) { printf("Yes\t\t%d\n", 
memory[i].size); 
} else { 
printf("No\t\t%d\n", memory[i].size); 
} 
} 
} 
 
int main() { 
// Initialize memory blocks 
int n = 5; // Number of memory blocks struct 
MemoryBlock memory[n]; 
initialize_memory(memory, n); 
21PD03-OPERATING SYSTEMS 
717822P321 44 
 
 
 
// Allocate memory to processes 
best_fit_allocation(memory, n, 1, 200); 
best_fit_allocation(memory, n, 2, 300); 
best_fit_allocation(memory, n, 3, 150); 
best_fit_allocation(memory, n, 4, 400); 
 
// Display memory status after allocation 
display_memory_status(memory, n); 
 
// Deallocate memory 
deallocate_memory(memory, n, 2); 
 
// Display memory status after deallocation 
display_memory_status(memory, n); 
 
return 0; 
} 
 
 
OUTPUT: 
 
 
 
 
 
 
 
PREPARATION 30 
 
LAB PERFORMANCE 30 
 
REPORT 40 
 
TOTAL 100 
 
INITIAL OF THE FACULTY 
 
 
 
RESULT: 
Thus the program to implement dynamic memory allocation using best fit algorithm executed 
successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 45 
 
 
 
Ex no : 9A  
IMPLEMENTATION OF LRU PAGE REPLACEMENT 
ALGORITHM Date : 06/05/24 
 
 
AIM: 
To write a C program to implement LRU page replacement algorithm. 
 
 
ALGORITHM: 
Step 1: Start the program. 
Step 2: Read the number of frames. 
Step 3: Read the number of pages. 
Step 4: Read the page numbers. 
Step 5: Initializethe values in frames to-1. 
Step 6: Allocate the pages in to frames byselecting thepage that has not been used for 
the longest period oftime. 
Step 7: Displaythenumber of pagefaults. 
Step 8: Stop the process. 
 
PROGRAM: 
 
#include <stdio.h> 
#include <stdbool.h> 
 
#define MAX_FRAMES 3 // Maximum number of frames in memory 
 
// Function to check if a page exists in memory 
bool is_page_in_memory(int page, int frames[], int n) { 
for (int i = 0; i < n; i++) { 
if (frames[i] == page) { 
return true; 
} 
} 
return false; 
} 
 
// Function to find the index of the least recently used page in 
memory int find_lru_index(int page_order[], int n, int frames[], int 
frame_count) { 
int lru_index = -1; 
int farthest_index = -1; 
for (int i = 0; i < frame_count; i++) { 
int j; 
for (j = n - 1; j > 0; j--) { 
if (frames[i] == page_order[j]) { if (j > 
farthest_index) { 
farthest_index = j; lru_index = i; 
} 
21PD03-OPERATING SYSTEMS 
717822P321 46 
 
 
break; 
} 
} 
if (j == 0) { 
return i; // Page was not found in reference string, so it's the least recently used 
} 
} 
return lru_index; 
} 
 
// Function to simulate page replacement using LRU algorithm 
void lru_page_replacement(int reference_string[], int reference_length, int 
frames[], int frame_count) { 
int page_order[reference_length]; // Array to store the order of page references 
int page_faults = 0; 
 
for (int i = 0; i < reference_length; i++) { 
int page = reference_string[i]; 
page_order[i] = page; 
 
if (!is_page_in_memory(page, frames, frame_count)) { 
page_faults++; 
int lru_index = find_lru_index(page_order, i, frames, frame_count); frames[lru_index] 
= page; 
} 
 
printf("Reference: %d, Frames: ", page); 
for (int j = 0; j < frame_count; j++) { 
printf("%d ", frames[j]); 
} 
printf("\n"); 
} 
 
printf("\nTotal Page Faults: %d\n", page_faults); 
} 
 
int main() { 
int reference_string[] = {1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}; // Reference string 
int reference_length = sizeof(reference_string) / sizeof(reference_string[0]); 
 
int frames[MAX_FRAMES] = {-1}; // Initialize frames with -1 indicating empty frame 
int frame_count = sizeof(frames) / sizeof(frames[0]); 
 
printf("LRU Page Replacement Simulation:\n"); 
lru_page_replacement(reference_string, reference_length, frames, frame_count); 
 
return 0; 
} 
21PD03-OPERATING SYSTEMS 
717822P321 47 
 
 
 
 
OUTPUT: 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
RESULT: 
Thus the program to implement LRU page replacement algorithm executed successfully. 
21PD03-OPERATING SYSTEMS 
717822P321 48 
 
 
 
 
 
Ex no : 9B  
IMPLEMENTATION OF FIFO ALGORITHM Date : 06/05/24 
 
AIM: 
To write a C program to implement FIFO algorithm. 
 
 
ALGORITHM: 
Step 1: Start the program. 
Step 2: Start traversing the pages. 
Step 3: Initialize the page and set to one 
until the page reaches the capacity 
Step 4: Simultaneously maintain the pages in 
the queue to perform FIFO. 
Step 5: Increment the page fault. 
Step 6: Store the current page. 
Step 7: Display the page. 
Step 8: Stop the program 
 
 
PROGRAM: 
#include <stdio.h> 
#include <stdbool.h> 
 
#define MAX_FRAMES 3 // Maximum number of frames in memory 
 
// Function to check if a page exists in memory 
bool is_page_in_memory(int page, int frames[], int frame_count) { for (int 
i = 0; i < frame_count; i++) { 
if (frames[i] == page) { return true; 
} 
} 
return false; 
} 
// Function to simulate page replacement using FIFO algorithm 
void fifo_page_replacement(int reference_string[], int reference_length, int frames[], int 
frame_count) { 
int page_faults = 0; 
int oldest_page_index = 0; 
 
for (int i = 0; i < reference_length; i++) { int page 
= reference_string[i]; 
 
if (!is_page_in_memory(page, frames, frame_count)) { page_faults++; 
frames[oldest_page_index] = page; 
21PD03-OPERATING SYSTEMS 
717822P321 49 
 
 
oldest_page_index = (oldest_page_index + 1) % frame_count; 
} 
 
printf("Reference: %d, Frames: ", page); for (int j 
= 0; j < frame_count; j++) { 
printf("%d ", frames[j]); 
} 
printf("\n"); 
} 
 
printf("\nTotal Page Faults: %d\n", page_faults); 
} 
int main() { 
int reference_string[] = {1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}; // Reference string int 
reference_length = sizeof(reference_string) / sizeof(reference_string[0]); 
 
int frames[MAX_FRAMES] = {-1}; // Initialize frames with -1 indicating empty frame int 
frame_count = sizeof(frames) / sizeof(frames[0]); 
 
printf("FIFO Page Replacement Simulation:\n"); 
fifo_page_replacement(reference_string, reference_length, frames, frame_count); 
 
return 0; 
} 
 
OUTPUT: 
 
 
 
PREPARATION 30 
 
LAB PERFORMANCE 30 
 
REPORT 40 
 
TOTAL 100 
 
INITIAL OF THE FACULTY 
 
RESULT: 
Thus the program to implement FIFO algorithm executed successfully. 